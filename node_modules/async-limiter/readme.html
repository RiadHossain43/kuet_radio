<html>
      <head>
        <meta charset="UTF-8">
        <title>readme.md</title>
      </head>
      <body>
        <h1 id="async-limiter">Async-Limiter</h1>
<p>A module for limiting concurrent asynchronous actions in flight. Forked from <a href="https://github.com/jessetane/queue">queue</a>.</p>
<p><a href="http://www.npmjs.org/async-limiter"><img src="http://img.shields.io/npm/v/async-limiter.svg?style=flat-square" alt="npm"></a>
<a href="https://travis-ci.org/STRML/async-limiter"><img src="https://img.shields.io/travis/STRML/async-limiter.svg?style=flat-square&amp;branch=master" alt="tests"></a>
<a href="https://coveralls.io/r/STRML/async-limiter"><img src="https://img.shields.io/coveralls/STRML/async-limiter.svg?style=flat-square&amp;branch=master" alt="coverage"></a></p>
<p>This module exports a class <code>Limiter</code> that implements some of the <code>Array</code> API.
Pass async functions (ones that accept a callback or return a promise) to an instance&#39;s additive array methods.</p>
<h2 id="motivation">Motivation</h2>
<p>Certain functions, like <code>zlib</code>, have <a href="https://github.com/nodejs/node/issues/8871#issuecomment-250915913">undesirable behavior</a> when
run at infinite concurrency.</p>
<p>In this case, it is actually faster, and takes far less memory, to limit concurrency.</p>
<p>This module should do the absolute minimum work necessary to queue up functions. PRs are welcome that would
make this module faster or lighter, but new functionality is not desired.</p>
<p>Style should confirm to nodejs/node style.</p>
<h2 id="example">Example</h2>
<pre><code class="lang-javascript">var Limiter = require(&#39;async-limiter&#39;)

var t = new Limiter({concurrency: 2});
var results = []

// add jobs using the familiar Array API
t.push(function (cb) {
  results.push(&#39;two&#39;)
  cb()
})

t.push(
  function (cb) {
    results.push(&#39;four&#39;)
    cb()
  },
  function (cb) {
    results.push(&#39;five&#39;)
    cb()
  }
)

t.unshift(function (cb) {
  results.push(&#39;one&#39;)
  cb()
})

t.splice(2, 0, function (cb) {
  results.push(&#39;three&#39;)
  cb()
})

// Jobs run automatically. If you want a callback when all are done,
// call &#39;onDone()&#39;.
t.onDone(function () {
  console.log(&#39;all done:&#39;, results)
})
</code></pre>
<h2 id="zlib-example">Zlib Example</h2>
<pre><code class="lang-js">const zlib = require(&#39;zlib&#39;);
const Limiter = require(&#39;async-limiter&#39;);

const message = {some: &quot;data&quot;};
const payload = new Buffer(JSON.stringify(message));

// Try with different concurrency values to see how this actually
// slows significantly with higher concurrency!
//
// 5:        1398.607ms
// 10:       1375.668ms
// Infinity: 4423.300ms
//
const t = new Limiter({concurrency: 5});
function deflate(payload, cb) {
  t.push(function(done) {
    zlib.deflate(payload, function(err, buffer) {
      done();
      cb(err, buffer);
    });
  });
}

console.time(&#39;deflate&#39;);
for(let i = 0; i &lt; 30000; ++i) {
  deflate(payload, function (err, buffer) {});
}
t.onDone(function() {
  console.timeEnd(&#39;deflate&#39;);
});
</code></pre>
<h2 id="install">Install</h2>
<p><code>npm install async-limiter</code></p>
<h2 id="test">Test</h2>
<p><code>npm test</code></p>
<h2 id="api">API</h2>
<h3 id="var-t-new-limiter-opts-"><code>var t = new Limiter([opts])</code></h3>
<p>Constructor. <code>opts</code> may contain inital values for:</p>
<ul>
<li><code>t.concurrency</code></li>
</ul>
<h2 id="instance-methods">Instance methods</h2>
<h3 id="t-ondone-fn-"><code>t.onDone(fn)</code></h3>
<p><code>fn</code> will be called once and only once, when the queue is empty.</p>
<h2 id="instance-methods-mixed-in-from-array">Instance methods mixed in from <code>Array</code></h2>
<p>Mozilla has docs on how these methods work <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">here</a>.</p>
<h3 id="t-push-element1-elementn-"><code>t.push(element1, ..., elementN)</code></h3>
<h3 id="t-unshift-element1-elementn-"><code>t.unshift(element1, ..., elementN)</code></h3>
<h3 id="t-splice-index-howmany-element1-elementn-"><code>t.splice(index , howMany[, element1[, ...[, elementN]]])</code></h3>
<h2 id="properties">Properties</h2>
<h3 id="t-concurrency"><code>t.concurrency</code></h3>
<p>Max number of jobs the queue should process concurrently, defaults to <code>Infinity</code>.</p>
<h3 id="t-length"><code>t.length</code></h3>
<p>Jobs pending + jobs to process (readonly).</p>

      </body>
    </html>
<html>
      <head>
        <meta charset="UTF-8">
        <title>README.md</title>
      </head>
      <body>
        <h1 id="engine-io-client">Engine.IO client</h1>
<p><a href="http://travis-ci.org/socketio/engine.io-client"><img src="https://travis-ci.org/socketio/engine.io-client.svg?branch=master" alt="Build Status"></a>
<a href="http://badge.fury.io/js/engine.io-client"><img src="https://badge.fury.io/js/engine.io-client.svg" alt="NPM version"></a></p>
<p>This is the client for <a href="http://github.com/socketio/engine.io">Engine.IO</a>,
the implementation of transport-based cross-browser/cross-device
bi-directional communication layer for <a href="http://github.com/socketio/socket.io">Socket.IO</a>.</p>
<h2 id="how-to-use">How to use</h2>
<h3 id="standalone">Standalone</h3>
<p>You can find an <code>engine.io.js</code> file in this repository, which is a
standalone build you can use as follows:</p>
<pre><code class="lang-html">&lt;script src=&quot;/path/to/engine.io.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  // eio = Socket
  var socket = eio(&#39;ws://localhost&#39;);
  socket.on(&#39;open&#39;, function(){
    socket.on(&#39;message&#39;, function(data){});
    socket.on(&#39;close&#39;, function(){});
  });
&lt;/script&gt;
</code></pre>
<h3 id="with-browserify">With browserify</h3>
<p>Engine.IO is a commonjs module, which means you can include it by using
<code>require</code> on the browser and package using <a href="http://browserify.org/">browserify</a>:</p>
<ol>
<li><p>install the client package</p>
<pre><code class="lang-bash"> $ npm install engine.io-client
</code></pre>
</li>
<li><p>write your app code</p>
<pre><code class="lang-js"> var socket = require(&#39;engine.io-client&#39;)(&#39;ws://localhost&#39;);
 socket.on(&#39;open&#39;, function(){
   socket.on(&#39;message&#39;, function(data){});
   socket.on(&#39;close&#39;, function(){});
 });
</code></pre>
</li>
<li><p>build your app bundle</p>
<pre><code class="lang-bash"> $ browserify app.js &gt; bundle.js
</code></pre>
</li>
<li><p>include on your page</p>
<pre><code class="lang-html"> &lt;script src=&quot;/path/to/bundle.js&quot;&gt;&lt;/script&gt;
</code></pre>
</li>
</ol>
<h3 id="sending-and-receiving-binary">Sending and receiving binary</h3>
<pre><code class="lang-html">&lt;script src=&quot;/path/to/engine.io.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  var socket = new eio.Socket(&#39;ws://localhost/&#39;);
  socket.binaryType = &#39;blob&#39;;
  socket.on(&#39;open&#39;, function () {
    socket.send(new Int8Array(5));
    socket.on(&#39;message&#39;, function(blob){});
    socket.on(&#39;close&#39;, function(){ });
  });
&lt;/script&gt;
</code></pre>
<h3 id="node-js">Node.JS</h3>
<p>Add <code>engine.io-client</code> to your <code>package.json</code> and then:</p>
<pre><code class="lang-js">var socket = require(&#39;engine.io-client&#39;)(&#39;ws://localhost&#39;);
socket.on(&#39;open&#39;, function(){
  socket.on(&#39;message&#39;, function(data){});
  socket.on(&#39;close&#39;, function(){});
});
</code></pre>
<h3 id="node-js-with-certificates">Node.js with certificates</h3>
<pre><code class="lang-js">var opts = {
  key: fs.readFileSync(&#39;test/fixtures/client.key&#39;),
  cert: fs.readFileSync(&#39;test/fixtures/client.crt&#39;),
  ca: fs.readFileSync(&#39;test/fixtures/ca.crt&#39;)
};

var socket = require(&#39;engine.io-client&#39;)(&#39;ws://localhost&#39;, opts);
socket.on(&#39;open&#39;, function(){
  socket.on(&#39;message&#39;, function(data){});
  socket.on(&#39;close&#39;, function(){});
});
</code></pre>
<h3 id="node-js-with-extraheaders">Node.js with extraHeaders</h3>
<pre><code class="lang-js">var opts = {
  extraHeaders: {
    &#39;X-Custom-Header-For-My-Project&#39;: &#39;my-secret-access-token&#39;,
    &#39;Cookie&#39;: &#39;user_session=NI2JlCKF90aE0sJZD9ZzujtdsUqNYSBYxzlTsvdSUe35ZzdtVRGqYFr0kdGxbfc5gUOkR9RGp20GVKza; path=/; expires=Tue, 07-Apr-2015 18:18:08 GMT; secure; HttpOnly&#39;
  }
};

var socket = require(&#39;engine.io-client&#39;)(&#39;ws://localhost&#39;, opts);
socket.on(&#39;open&#39;, function(){
  socket.on(&#39;message&#39;, function(data){});
  socket.on(&#39;close&#39;, function(){});
});
</code></pre>
<h2 id="features">Features</h2>
<ul>
<li>Lightweight</li>
<li>Runs on browser and node.js seamlessly</li>
<li>Transports are independent of <code>Engine</code><ul>
<li>Easy to debug</li>
<li>Easy to unit test</li>
</ul>
</li>
<li>Runs inside HTML5 WebWorker</li>
<li>Can send and receive binary data<ul>
<li>Receives as ArrayBuffer or Blob when in browser, and Buffer or ArrayBuffer
in Node</li>
<li>When XHR2 or WebSockets are used, binary is emitted directly. Otherwise
binary is encoded into base64 strings, and decoded when binary types are
supported.</li>
<li>With browsers that don&#39;t support ArrayBuffer, an object { base64: true,
data: dataAsBase64String } is emitted on the <code>message</code> event.</li>
</ul>
</li>
</ul>
<h2 id="api">API</h2>
<h3 id="socket">Socket</h3>
<p>The client class. Mixes in <a href="http://github.com/component/emitter">Emitter</a>.
Exposed as <code>eio</code> in the browser standalone build.</p>
<h4 id="properties">Properties</h4>
<ul>
<li><code>protocol</code> <em>(Number)</em>: protocol revision number</li>
<li><code>binaryType</code> <em>(String)</em> : can be set to &#39;arraybuffer&#39; or &#39;blob&#39; in browsers,
and <code>buffer</code> or <code>arraybuffer</code> in Node. Blob is only used in browser if it&#39;s
supported.</li>
</ul>
<h4 id="events">Events</h4>
<ul>
<li><code>open</code><ul>
<li>Fired upon successful connection.</li>
</ul>
</li>
<li><code>message</code><ul>
<li>Fired when data is received from the server.</li>
<li><strong>Arguments</strong><ul>
<li><code>String</code> | <code>ArrayBuffer</code>: utf-8 encoded data or ArrayBuffer containing
binary data</li>
</ul>
</li>
</ul>
</li>
<li><code>close</code><ul>
<li>Fired upon disconnection. In compliance with the WebSocket API spec, this event may be
fired even if the <code>open</code> event does not occur (i.e. due to connection error or <code>close()</code>).</li>
</ul>
</li>
<li><code>error</code><ul>
<li>Fired when an error occurs.</li>
</ul>
</li>
<li><code>flush</code><ul>
<li>Fired upon completing a buffer flush</li>
</ul>
</li>
<li><code>drain</code><ul>
<li>Fired after <code>drain</code> event of transport if writeBuffer is empty</li>
</ul>
</li>
<li><code>upgradeError</code><ul>
<li>Fired if an error occurs with a transport we&#39;re trying to upgrade to.</li>
</ul>
</li>
<li><code>upgrade</code><ul>
<li>Fired upon upgrade success, after the new transport is set</li>
</ul>
</li>
<li><code>ping</code><ul>
<li>Fired upon <em>flushing</em> a ping packet (ie: actual packet write out)</li>
</ul>
</li>
<li><code>pong</code><ul>
<li>Fired upon receiving a pong packet.</li>
</ul>
</li>
</ul>
<h4 id="methods">Methods</h4>
<ul>
<li><strong>constructor</strong><ul>
<li>Initializes the client</li>
<li><strong>Parameters</strong><ul>
<li><code>String</code> uri</li>
<li><code>Object</code>: optional, options object</li>
</ul>
</li>
<li><strong>Options</strong><ul>
<li><code>agent</code> (<code>http.Agent</code>): <code>http.Agent</code> to use, defaults to <code>false</code> (NodeJS only)</li>
<li><code>upgrade</code> (<code>Boolean</code>): defaults to true, whether the client should try
to upgrade the transport from long-polling to something better.</li>
<li><code>forceJSONP</code> (<code>Boolean</code>): forces JSONP for polling transport.</li>
<li><code>jsonp</code> (<code>Boolean</code>): determines whether to use JSONP when
necessary for polling. If disabled (by settings to false) an error will
be emitted (saying &quot;No transports available&quot;) if no other transports
are available. If another transport is available for opening a
connection (e.g. WebSocket) that transport
will be used instead.</li>
<li><code>forceBase64</code> (<code>Boolean</code>): forces base 64 encoding for polling transport even when XHR2 responseType is available and WebSocket even if the used standard supports binary.</li>
<li><code>enablesXDR</code> (<code>Boolean</code>): enables XDomainRequest for IE8 to avoid loading bar flashing with click sound. default to <code>false</code> because XDomainRequest has a flaw of not sending cookie.</li>
<li><code>timestampRequests</code> (<code>Boolean</code>): whether to add the timestamp with each
transport request. Note: polling requests are always stamped unless this
option is explicitly set to <code>false</code> (<code>false</code>)</li>
<li><code>timestampParam</code> (<code>String</code>): timestamp parameter (<code>t</code>)</li>
<li><code>policyPort</code> (<code>Number</code>): port the policy server listens on (<code>843</code>)</li>
<li><code>path</code> (<code>String</code>): path to connect to, default is <code>/engine.io</code></li>
<li><code>transports</code> (<code>Array</code>): a list of transports to try (in order).
Defaults to <code>[&#39;polling&#39;, &#39;websocket&#39;]</code>. <code>Engine</code>
always attempts to connect directly with the first one, provided the
feature detection test for it passes.</li>
<li><code>transportOptions</code> (<code>Object</code>): hash of options, indexed by transport name, overriding the common options for the given transport</li>
<li><code>rememberUpgrade</code> (<code>Boolean</code>): defaults to false.
If true and if the previous websocket connection to the server succeeded,
the connection attempt will bypass the normal upgrade process and will initially
try websocket. A connection attempt following a transport error will use the
normal upgrade process. It is recommended you turn this on only when using
SSL/TLS connections, or if you know that your network does not block websockets.</li>
<li><code>pfx</code> (<code>String</code>): Certificate, Private key and CA certificates to use for SSL. Can be used in Node.js client environment to manually specify certificate information.</li>
<li><code>key</code> (<code>String</code>): Private key to use for SSL. Can be used in Node.js client environment to manually specify certificate information.</li>
<li><code>passphrase</code> (<code>String</code>): A string of passphrase for the private key or pfx. Can be used in Node.js client environment to manually specify certificate information.</li>
<li><code>cert</code> (<code>String</code>): Public x509 certificate to use. Can be used in Node.js client environment to manually specify certificate information.</li>
<li><code>ca</code> (<code>String</code>|<code>Array</code>): An authority certificate or array of authority certificates to check the remote host against.. Can be used in Node.js client environment to manually specify certificate information.</li>
<li><code>ciphers</code> (<code>String</code>): A string describing the ciphers to use or exclude. Consult the <a href="http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT">cipher format list</a> for details on the format. Can be used in Node.js client environment to manually specify certificate information.</li>
<li><code>rejectUnauthorized</code> (<code>Boolean</code>): If true, the server certificate is verified against the list of supplied CAs. An &#39;error&#39; event is emitted if verification fails. Verification happens at the connection level, before the HTTP request is sent. Can be used in Node.js client environment to manually specify certificate information.</li>
<li><code>perMessageDeflate</code> (<code>Object|Boolean</code>): parameters of the WebSocket permessage-deflate extension
(see <a href="https://github.com/einaros/ws">ws module</a> api docs). Set to <code>false</code> to disable. (<code>true</code>)<ul>
<li><code>threshold</code> (<code>Number</code>): data is compressed only if the byte size is above this value. This option is ignored on the browser. (<code>1024</code>)</li>
</ul>
</li>
<li><code>extraHeaders</code> (<code>Object</code>): Headers that will be passed for each request to the server (via xhr-polling and via websockets). These values then can be used during handshake or for special proxies. Can only be used in Node.js client environment.</li>
<li><code>onlyBinaryUpgrades</code> (<code>Boolean</code>): whether transport upgrades should be restricted to transports supporting binary data (<code>false</code>)</li>
<li><code>forceNode</code> (<code>Boolean</code>): Uses NodeJS implementation for websockets - even if there is a native Browser-Websocket available, which is preferred by default over the NodeJS implementation. (This is useful when using hybrid platforms like nw.js or electron) (<code>false</code>, NodeJS only)</li>
<li><code>localAddress</code> (<code>String</code>): the local IP address to connect to</li>
</ul>
</li>
<li><strong>Polling-only options</strong><ul>
<li><code>requestTimeout</code> (<code>Number</code>): Timeout for xhr-polling requests in milliseconds (<code>0</code>)</li>
</ul>
</li>
<li><strong>Websocket-only options</strong><ul>
<li><code>protocols</code> (<code>Array</code>): a list of subprotocols (see <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers#Subprotocols">MDN reference</a>)</li>
</ul>
</li>
</ul>
</li>
<li><code>send</code><ul>
<li>Sends a message to the server</li>
<li><strong>Parameters</strong><ul>
<li><code>String</code> | <code>ArrayBuffer</code> | <code>ArrayBufferView</code> | <code>Blob</code>: data to send</li>
<li><code>Object</code>: optional, options object</li>
<li><code>Function</code>: optional, callback upon <code>drain</code></li>
</ul>
</li>
<li><strong>Options</strong><ul>
<li><code>compress</code> (<code>Boolean</code>): whether to compress sending data. This option is ignored and forced to be <code>true</code> on the browser. (<code>true</code>)</li>
</ul>
</li>
</ul>
</li>
<li><code>close</code><ul>
<li>Disconnects the client.</li>
</ul>
</li>
</ul>
<h3 id="transport">Transport</h3>
<p>The transport class. Private. <em>Inherits from EventEmitter</em>.</p>
<h4 id="events">Events</h4>
<ul>
<li><code>poll</code>: emitted by polling transports upon starting a new request</li>
<li><code>pollComplete</code>: emitted by polling transports upon completing a request</li>
<li><code>drain</code>: emitted by polling transports upon a buffer drain</li>
</ul>
<h2 id="tests">Tests</h2>
<p><code>engine.io-client</code> is used to test
<a href="http://github.com/socketio/engine.io">engine</a>. Running the <code>engine.io</code>
test suite ensures the client works and vice-versa.</p>
<p>Browser tests are run using <a href="https://github.com/defunctzombie/zuul">zuul</a>. You can
run the tests locally using the following command.</p>
<pre><code>./node_modules/.bin/zuul --local 8080 -- test/index.js
</code></pre><p>Additionally, <code>engine.io-client</code> has a standalone test suite you can run
with <code>make test</code> which will run node.js and browser tests. You must have zuul setup with
a saucelabs account.</p>
<h2 id="support">Support</h2>
<p>The support channels for <code>engine.io-client</code> are the same as <code>socket.io</code>:</p>
<ul>
<li>irc.freenode.net <strong>#socket.io</strong></li>
<li><a href="http://groups.google.com/group/socket_io">Google Groups</a></li>
<li><a href="http://socket.io">Website</a></li>
</ul>
<h2 id="development">Development</h2>
<p>To contribute patches, run tests or benchmarks, make sure to clone the
repository:</p>
<pre><code class="lang-bash">git clone git://github.com/socketio/engine.io-client.git
</code></pre>
<p>Then:</p>
<pre><code class="lang-bash">cd engine.io-client
npm install
</code></pre>
<p>See the <code>Tests</code> section above for how to run tests before submitting any patches.</p>
<h2 id="license">License</h2>
<p>MIT - Copyright (c) 2014 Automattic, Inc.</p>

      </body>
    </html>